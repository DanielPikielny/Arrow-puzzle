"""
Arrow Puzzle — Solver, Generator, and CLI
=========================================
Rules: An arrow can be removed if it would slide off the board in the
direction it points without hitting any other piece. The goal is to
clear the board entirely.

Generation strategy: Instead of generating random boards and discarding
unsolvable ones, we build boards *backwards* from an empty state. Each
step places an arrow that *could* legally be removed, guaranteeing the
final board is solvable by construction. This is dramatically faster
than rejection sampling, especially at higher difficulties.
"""

from collections import deque
import random
from typing import Optional

# ---------------------------------------------------------------------------
# Types
# ---------------------------------------------------------------------------

Board = list[list[str]]
BoardTuple = tuple[tuple[str, ...], ...]

ARROWS = ('^', 'v', '<', '>')
DIRECTIONS: dict[str, tuple[int, int]] = {
    '^': (-1, 0),
    'v': (1, 0),
    '<': (0, -1),
    '>': (0, 1),
}

# ---------------------------------------------------------------------------
# Core helpers
# ---------------------------------------------------------------------------

def board_to_tuple(board: Board) -> BoardTuple:
    return tuple(tuple(row) for row in board)


def print_board(board: Board) -> None:
    separator = '+' + '+'.join('-' * 3 for _ in board[0]) + '+'
    print(separator)
    for row in board:
        print('|' + '|'.join(f' {cell} ' for cell in row) + '|')
    print(separator)


def copy_board(board: Board) -> Board:
    return [list(row) for row in board]


def empty_board(rows: int, cols: int) -> Board:
    return [['.' for _ in range(cols)] for _ in range(rows)]

# ---------------------------------------------------------------------------
# Move logic
# ---------------------------------------------------------------------------

def can_remove(board: Board, r: int, c: int) -> bool:
    """Return True if the arrow at (r, c) can legally slide off the board."""
    arrow = board[r][c]
    if arrow not in DIRECTIONS:
        return False
    dr, dc = DIRECTIONS[arrow]
    nr, nc = r + dr, c + dc
    while 0 <= nr < len(board) and 0 <= nc < len(board[0]):
        if board[nr][nc] != '.':
            return False
        nr += dr
        nc += dc
    return True  # reached the edge unobstructed


def apply_removal(board: Board, r: int, c: int) -> Board:
    """Return a new board with the arrow at (r, c) removed (cell becomes '.')."""
    new_board = copy_board(board)
    new_board[r][c] = '.'

    return new_board

# ---------------------------------------------------------------------------
# Solver  (BFS over board states)
# ---------------------------------------------------------------------------

def solve(board: Board) -> Optional[list[tuple[int, int]]]:
    """
    Return the sequence of (row, col) removals that clears the board,
    or None if unsolvable. Uses BFS so the solution is always shortest.
    """
    start = board_to_tuple(board)
    queue: deque[tuple[BoardTuple, list[tuple[int, int]]]] = deque([(start, [])])
    visited: set[BoardTuple] = {start}

    while queue:
        state, path = queue.popleft()
        board_now = [list(row) for row in state]

        if all(cell == '.' for row in board_now for cell in row):
            return path

        rows, cols = len(board_now), len(board_now[0])
        for r in range(rows):
            for c in range(cols):
                if can_remove(board_now, r, c):
                    next_board = apply_removal(board_now, r, c)
                    next_state = board_to_tuple(next_board)
                    if next_state not in visited:
                        visited.add(next_state)
                        queue.append((next_state, path + [(r, c)]))
    return None


def difficulty_score(board: Board) -> Optional[int]:
    """Number of moves in the shortest solution, or None if unsolvable."""
    solution = solve(board)
    return len(solution) if solution is not None else None

# ---------------------------------------------------------------------------
# Generator  (reverse construction — always solvable)
# ---------------------------------------------------------------------------

def generate_board(rows: int, cols: int, num_arrows: int) -> Board:
    """
    Build a solvable board by working backwards from an empty grid.

    We maintain a list of 'solution steps in reverse': at each step we
    pick an empty cell and a direction such that placing an arrow there
    would be a legal removal from the resulting board. This is equivalent
    to ensuring the arrow can reach the edge without obstruction *at the
    moment it is conceptually placed last in the reverse sequence*.

    In practice: we start empty, then repeatedly add arrows that are
    currently removable. The reverse of the add order is a valid solution.
    """
    board = empty_board(rows, cols)
    placed = 0
    attempts = 0
    max_attempts = num_arrows * 200  # safety valve

    while placed < num_arrows and attempts < max_attempts:
        attempts += 1
        r = random.randrange(rows)
        c = random.randrange(cols)
        if board[r][c] != '.':
            continue
        arrow = random.choice(ARROWS)
        board[r][c] = arrow
        if not can_remove(board, r, c):
            # Placing this arrow here would make it immediately stuck —
            # roll back and try again.
            board[r][c] = '.'
        else:
            placed += 1

    return board


def generate_solvable(
    rows: int,
    cols: int,
    min_difficulty: int = 5,
    max_difficulty: Optional[int] = None,
    max_tries: int = 500,
) -> tuple[Board, int]:
    """
    Generate a board guaranteed to be solvable with at least `min_difficulty`
    moves. Because `generate_board` already guarantees solvability, we only
    loop to satisfy the difficulty constraint, which converges quickly.
    """
    # Heuristic: more arrows → harder puzzle (up to board capacity)
    target_arrows = max(min_difficulty, min(rows * cols - 1, min_difficulty + 4))

    for _ in range(max_tries):
        board = generate_board(rows, cols, num_arrows=target_arrows)
        score = difficulty_score(board)
        if score is None:
            continue  # shouldn't happen, but be defensive
        if score >= min_difficulty:
            if max_difficulty is None or score <= max_difficulty:
                return board, score
        # Adjust density based on whether we're over or under target
        if score < min_difficulty:
            target_arrows = min(rows * cols - 1, target_arrows + 1)
        elif max_difficulty and score > max_difficulty:
            target_arrows = max(1, target_arrows - 1)

    raise RuntimeError(
        f"Could not generate a board with difficulty ≥ {min_difficulty} "
        f"after {max_tries} attempts. Try a larger grid or lower difficulty."
    )

# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main() -> None:
    print("=== Arrow Puzzle Generator ===\n")
    rows = int(input("Rows:           "))
    cols = int(input("Cols:           "))
    min_diff = int(input("Min difficulty: "))

    print("\nGenerating puzzle…")
    board, score = generate_solvable(rows, cols, min_difficulty=min_diff)

    print("\nGenerated Board:")
    print_board(board)
    print(f"\nDifficulty (shortest solution): {score} move(s)")

    show = input("\nShow solution? [y/N] ").strip().lower()
    if show == 'y':
        solution = solve(board)
        print("\nSolution (row, col) in order:")
        temp = copy_board(board)
        for i, (r, c) in enumerate(solution, 1):
            arrow = temp[r][c]
            print(f"  Step {i:>2}: remove arrow at row {r}, col {c}  ({arrow})")
            temp = apply_removal(temp, r, c)

if __name__ == "__main__":
    main()
